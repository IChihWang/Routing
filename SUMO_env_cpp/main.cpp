#include <iostream>
#include <sstream>
#include <string>
#include <fstream>
#include <cmath>
#include "LaneAdviser.h"
#include "Intersection_manager.h"
#include "server.h"
#include "json.hpp"

using namespace std;
using json = nlohmann::json;


SUMO_Traci traci;
uint16_t _N_TIME_STEP;
float _TIME_STEP;

map<string, string> src_dst_dict;

void initial_sumo();
void read_src_dst_file(string src_dst_file_name);
void run_sumo(Thread_Worker& router_thread);

int main(int argc, char* argv[])
{
    cout << "Usage: ./main <grid_size> <src_dst_file.json>" << endl;

    string src_dst_file_name = "data/routes/";
    // Parse the input
    if (argc >= 3) {
        string grid_size_str = argv[1];
        _grid_size = stoi(grid_size_str);
        src_dst_file_name += argv[2];
    }
    else {
        cout << "Wrong number of arguments" << endl;
        exit(-1);
    }

    // Read src_dst_dict
    read_src_dst_file(src_dst_file_name);

    // Initialization
    initial_client_handler();
    initial_sumo();

    read_load_adv_data();
    read_inter_info_data();
    read_inter_length_data();

    Thread_Worker router_thread;     // New thread to send/receive routing requests/results  (do this after initial_client_handler();)

    // Run sumo simulation (run_sumo in python version)
    traci.simulationStep(5);

    // SUMO simulation
    run_sumo(router_thread);


    // TODO: get result from router first before updating the str

    traci.close();

    return 0;
}

// Initial SUMO
void initial_sumo() {
    traci.connect("localhost", SUMO_PORT);
}

// Read the source/destination file generated by python
void read_src_dst_file(string src_dst_file_name) {
    ifstream file(src_dst_file_name);

    if (!file.is_open()) {
        cout << "Fail to open the src_dst file in data/routes/" << endl;
        exit(-1);
    }

    json data;
    file >> data;
    file.close();

    for (const auto& src_dst_data_map : data.items()) {
        string car_id = src_dst_data_map.key();
        tuple<uint16_t, uint16_t, string> src_dst_data = src_dst_data_map.value();
        src_dst_dict[car_id] = get<2>(src_dst_data);
    }
}

void run_sumo(Thread_Worker& router_thread) {
    double simu_step = 0;

    // Create a list with intersection managers
    map<Coord, IntersectionManager*> intersection_map;
    for (uint16_t i = 1; i <= _grid_size; i++) {
        for (uint16_t j = 1; j <= _grid_size; j++) {
            Coord coordinate(i, j);
            IntersectionManager* intersection = new IntersectionManager(coordinate);
            intersection_map[coordinate] = intersection;
        }
    }

    // Connect intersections for spillback prevention
    for (uint16_t i = 1; i <= _grid_size; i++) {
        for (uint16_t j = 1; j <= _grid_size; j++) {
            Coord coordinate(i, j);
            if (i <= _grid_size - 1) {
                Coord target_coordinate(i + 1, j);
                (*(intersection_map[coordinate])).connect(1, (*(intersection_map[target_coordinate])), 3);
            }
            if (j <= _grid_size - 1) {
                Coord target_coordinate(i, j + 1);
                (*(intersection_map[coordinate])).connect(2, (*(intersection_map[target_coordinate])), 0);
            }
        }
    }

    map<string, Car_Info> car_info_dict;            // Record car states
    vector<string> to_delete_car_in_database;     // Car exit the network

    // Start simulation
    while (traci.simulation.getMinExpectedNumber() > 0) {
        // Early terminate the simulation
        if (int(simu_step * 10) / 10.0 >= _N_TIME_STEP) {
            router_thread.route_request = "End Connection";
            // Start workers
            {
                unique_lock<mutex> worker_lock(router_thread.request_worker_mutex);
                router_thread.request_worker_condition_variable.notify_all();
            }
            break;
        }

        traci.simulationStep();
        vector<string> all_c = traci.vehicle.getIDList();

        // Send route requests
        if (fmod(simu_step, ROUTING_PERIOD) < _TIME_STEP) {
            string server_send_str = "";
            for (auto& [car_id, car_info] : car_info_dict) {
                IntersectionManager* intersection_manager_ptr = car_info.intersection_manager_ptr;
                if (intersection_manager_ptr != nullptr) {
                    IntersectionManager& intersection_manager = *intersection_manager_ptr;
                    Car_Info_In_Intersection car_data = intersection_manager.get_car_info_for_route(car_id);
                    if (car_data.is_skip_car == false) {
                        double position_at_offset = car_data.position_at_offset;
                        uint16_t time_offset_step = car_data.time_offset_step;
                        string src_intersection_id = car_data.src_intersection_id;
                        uint8_t direction_of_src_intersection = car_data.direction_of_src_intersection;
                        uint8_t src_shift_num = car_data.src_shift_num;
                        car_info.src_shift_num = src_shift_num;

                        if (src_intersection_id.compare(car_info.dst_node_idx) != 0) {
                            server_send_str += car_id + ",";
                            server_send_str += car_info.route_state + ",";
                            server_send_str += to_string(car_info.car_length) + ",";
                            server_send_str += src_intersection_id + ",";
                            server_send_str += to_string(direction_of_src_intersection) + ",";
                            server_send_str += to_string(time_offset_step) + ",";               // Step that the datacenter needs to take
                            server_send_str += get_string_from_double(position_at_offset, 2) + ",";       // The position at the specific time
                            server_send_str += car_info.dst_node_idx + ";";
                        }
                        else {
                            server_send_str += car_id + ",";
                            server_send_str += string("LEAVING") + ";";
                        }
                    }
                    else {
                        server_send_str += car_id + ",";
                        server_send_str += string("PAUSE") + ";";
                    }
                }
            }

            for (const auto& car_id : to_delete_car_in_database) {
                server_send_str += car_id + ",";
                server_send_str += string("EXIT") + ";";
            }

                to_delete_car_in_database = []
                to_handler_queue.put(server_send_str)
        }



        // TODO: add is_scheduled

    }

    // Delete the intersection manager
    for (const auto& [intersection_id, manager_ptr] : intersection_map) {
        delete manager_ptr;
    }
}
